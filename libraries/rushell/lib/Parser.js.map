{"version":3,"file":"Parser.js","sourceRoot":"","sources":["../src/Parser.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport { ParseError } from './ParseError';\r\nimport { Tokenizer, Token, TokenKind } from './Tokenizer';\r\nimport { AstNode, AstScript, AstCommand, AstCompoundWord, AstText } from './AstNode';\r\n\r\nexport class Parser {\r\n  private readonly _tokenizer: Tokenizer;\r\n  private _peekedToken: Token | undefined;\r\n\r\n  public constructor(tokenizer: Tokenizer) {\r\n    this._tokenizer = tokenizer;\r\n    this._peekedToken = undefined;\r\n  }\r\n\r\n  public parse(): AstScript {\r\n    const script: AstScript = new AstScript();\r\n\r\n    const startingToken: Token = this._peekToken();\r\n\r\n    const astCommand: AstCommand | undefined = this._parseCommand();\r\n\r\n    if (!astCommand) {\r\n      throw new ParseError('Expecting a command', startingToken.range);\r\n    }\r\n\r\n    const nextToken: Token = this._peekToken();\r\n\r\n    if (nextToken.kind !== TokenKind.EndOfInput) {\r\n      throw new ParseError(`Unexpected token: ${TokenKind[nextToken.kind]}`, nextToken.range);\r\n    }\r\n\r\n    script.body = astCommand;\r\n\r\n    return script;\r\n  }\r\n\r\n  private _parseCommand(): AstCommand | undefined {\r\n    this._skipWhitespace();\r\n\r\n    const startingToken: Token = this._peekToken();\r\n\r\n    const command: AstCommand = new AstCommand();\r\n    command.commandPath = this._parseCompoundWord();\r\n    if (!command.commandPath) {\r\n      throw new ParseError('Expecting a command path', startingToken.range);\r\n    }\r\n\r\n    while (this._skipWhitespace()) {\r\n      const compoundWord: AstCompoundWord | undefined = this._parseCompoundWord();\r\n      if (!compoundWord) {\r\n        break;\r\n      }\r\n      command.arguments.push(compoundWord);\r\n    }\r\n\r\n    return command;\r\n  }\r\n\r\n  private _parseCompoundWord(): AstCompoundWord | undefined {\r\n    const compoundWord: AstCompoundWord = new AstCompoundWord();\r\n\r\n    for (;;) {\r\n      const node: AstNode | undefined = this._parseText();\r\n      if (!node) {\r\n        break;\r\n      }\r\n      compoundWord.parts.push(node);\r\n    }\r\n\r\n    if (compoundWord.parts.length === 0) {\r\n      // We didn't parse a word\r\n      return undefined;\r\n    }\r\n\r\n    return compoundWord;\r\n  }\r\n\r\n  private _parseText(): AstText | undefined {\r\n    const token: Token = this._peekToken();\r\n\r\n    if (token.kind === TokenKind.Text) {\r\n      this._readToken();\r\n\r\n      const astText: AstText = new AstText();\r\n      astText.token = token;\r\n      astText.range = token.range;\r\n      return astText;\r\n    }\r\n\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * Skips any whitespace tokens.  Returns true if any whitespace was actually encountered.\r\n   */\r\n  private _skipWhitespace(): boolean {\r\n    let sawWhitespace: boolean = false;\r\n    while (this._peekToken().kind === TokenKind.Spaces) {\r\n      this._readToken();\r\n      sawWhitespace = true;\r\n    }\r\n    if (this._peekToken().kind === TokenKind.EndOfInput) {\r\n      sawWhitespace = true;\r\n    }\r\n    return sawWhitespace;\r\n  }\r\n\r\n  private _readToken(): Token {\r\n    if (this._peekedToken) {\r\n      const token: Token = this._peekedToken;\r\n      this._peekedToken = undefined;\r\n      return token;\r\n    } else {\r\n      return this._tokenizer.readToken();\r\n    }\r\n  }\r\n\r\n  private _peekToken(): Token {\r\n    if (!this._peekedToken) {\r\n      this._peekedToken = this._tokenizer.readToken();\r\n    }\r\n    return this._peekedToken;\r\n  }\r\n}\r\n"]}