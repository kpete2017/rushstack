{"version":3,"file":"Tokenizer.js","sourceRoot":"","sources":["../src/Tokenizer.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport { TextRange } from './TextRange';\r\nimport { ParseError } from './ParseError';\r\n\r\nexport enum TokenKind {\r\n  // One or more spaces/tabs\r\n  Spaces,\r\n\r\n  // A single newline sequence such as CRLF or LF\r\n  NewLine,\r\n\r\n  // A general character without any special meaning\r\n  OtherCharacter,\r\n\r\n  // A sequence of characters that doesn't contain any symbols with special meaning\r\n  // Characters can be escaped, in which case the Token.text may differ from the\r\n  // Token.range.toString()\r\n  Text,\r\n\r\n  // The \"&&\" operator, which executes the following command only if the preceding command\r\n  // succeeded (i.e. returned a zero exit code).\r\n  AndIf,\r\n\r\n  // A double-quoted string which can do variable expansions\r\n  DoubleQuotedText,\r\n\r\n  // A dollar sign followed by an environment variable name\r\n  DollarVariable,\r\n\r\n  // The end of the input string\r\n  EndOfInput\r\n}\r\n\r\nexport class Token {\r\n  public readonly kind: TokenKind;\r\n  public readonly range: TextRange;\r\n\r\n  /**\r\n   * The extracted content, which depends on the type:\r\n   *\r\n   * Text: The unescaped content\r\n   * DoubleQuotedText: The unescaped contents inside the quotes.\r\n   * DollarVariable: The variable name without the \"$\"\r\n   */\r\n  public readonly text: string;\r\n\r\n  public constructor(kind: TokenKind, range: TextRange, text?: string) {\r\n    this.kind = kind;\r\n    this.range = range;\r\n    this.text = text === undefined ? this.range.toString() : text;\r\n  }\r\n\r\n  public toString(): string {\r\n    return this.text;\r\n  }\r\n}\r\n\r\nconst textCharacterRegExp: RegExp = /[a-z0-9_\\\\]/i;\r\nconst startVariableCharacterRegExp: RegExp = /[a-z_]/i;\r\nconst variableCharacterRegExp: RegExp = /[a-z0-9_]/i;\r\n\r\nexport class Tokenizer {\r\n  public readonly input: TextRange;\r\n  private _currentIndex: number;\r\n\r\n  public constructor(input: TextRange | string) {\r\n    if (typeof input === 'string') {\r\n      this.input = TextRange.fromString(input);\r\n    } else {\r\n      this.input = input;\r\n    }\r\n    this._currentIndex = this.input.pos;\r\n  }\r\n\r\n  private static _isSpace(c: string | undefined): boolean {\r\n    // You can empirically test whether shell treats a given character as whitespace like this:\r\n    // echo $(echo -e a '\\u0009' b)\r\n    // If you get \"a b\" it means the tab character (Unicode 0009) is being collapsed away.\r\n    // If you get \"a   b\" then the invisible character is being padded like a normal letter.\r\n    return c === ' ' || c === '\\t';\r\n  }\r\n\r\n  public get currentIndex(): number {\r\n    return this._currentIndex;\r\n  }\r\n\r\n  public readToken(): Token {\r\n    const input: TextRange = this.input;\r\n\r\n    const startIndex: number = this._currentIndex;\r\n    const firstChar: string | undefined = this._peekCharacter();\r\n\r\n    // Reached end of input yet?\r\n    if (firstChar === undefined) {\r\n      return new Token(TokenKind.EndOfInput, TextRange.empty);\r\n    }\r\n\r\n    // Is it a sequence of whitespace?\r\n    if (Tokenizer._isSpace(firstChar)) {\r\n      this._readCharacter();\r\n\r\n      while (Tokenizer._isSpace(this._peekCharacter())) {\r\n        this._readCharacter();\r\n      }\r\n\r\n      return new Token(TokenKind.Spaces, input.getNewRange(startIndex, this._currentIndex));\r\n    }\r\n\r\n    // Is it a newline?\r\n    if (firstChar === '\\r') {\r\n      this._readCharacter();\r\n      if (this._peekCharacter() === '\\n') {\r\n        this._readCharacter();\r\n      }\r\n      return new Token(TokenKind.NewLine, input.getNewRange(startIndex, this._currentIndex));\r\n    } else if (firstChar === '\\n') {\r\n      this._readCharacter();\r\n      return new Token(TokenKind.NewLine, input.getNewRange(startIndex, this._currentIndex));\r\n    }\r\n\r\n    // Is it a double-quoted string?\r\n    if (firstChar === '\"') {\r\n      this._readCharacter(); // consume the opening quote\r\n\r\n      let text: string = '';\r\n      let c: string | undefined = this._peekCharacter();\r\n      while (c !== '\"') {\r\n        if (c === undefined) {\r\n          throw new ParseError(\r\n            'The double-quoted string is missing the ending quote',\r\n            input.getNewRange(startIndex, this._currentIndex)\r\n          );\r\n        }\r\n        if (c === '\\r' || c === '\\n') {\r\n          throw new ParseError(\r\n            'Newlines are not supported inside strings',\r\n            input.getNewRange(this._currentIndex, this._currentIndex + 1)\r\n          );\r\n        }\r\n\r\n        // NOTE: POSIX says that backslash acts as an escape character inside a double-quoted string\r\n        // ONLY if followed by certain other characters.  For example, yes for \"a\\$\" but no for \"a\\t\".\r\n        // Whereas Dash says yes for \"a\\t\" but no for \"a\\q\".  And then Bash says yes for \"a\\t\".\r\n        // This goes against Rushell's goal of being intuitive:  Nobody should have to memorize a list\r\n        // of alphabet letters that cannot be escaped.  So we just say that backslash is *always* an\r\n        // escape character inside a double-quoted string.\r\n        //\r\n        // NOTE: Dash interprets \"\\t\" as a tab character, but Bash does not.\r\n        if (c === '\\\\') {\r\n          this._readCharacter(); // discard the backslash\r\n          if (this._peekCharacter() === undefined) {\r\n            throw new ParseError(\r\n              'A backslash must be followed by another character',\r\n              input.getNewRange(this._currentIndex, this._currentIndex + 1)\r\n            );\r\n          }\r\n          // Add the escaped character\r\n          text += this._readCharacter();\r\n        } else {\r\n          text += this._readCharacter();\r\n        }\r\n\r\n        c = this._peekCharacter();\r\n      }\r\n      this._readCharacter(); // consume the closing quote\r\n\r\n      return new Token(TokenKind.DoubleQuotedText, input.getNewRange(startIndex, this._currentIndex), text);\r\n    }\r\n\r\n    // Is it a text token?\r\n    if (textCharacterRegExp.test(firstChar)) {\r\n      let text: string = '';\r\n      let c: string | undefined = firstChar;\r\n      do {\r\n        if (c === '\\\\') {\r\n          this._readCharacter(); // discard the backslash\r\n          if (this._peekCharacter() === undefined) {\r\n            throw new ParseError(\r\n              'A backslash must be followed by another character',\r\n              input.getNewRange(this._currentIndex, this._currentIndex + 1)\r\n            );\r\n          }\r\n          // Add the escaped character\r\n          text += this._readCharacter();\r\n        } else {\r\n          text += this._readCharacter();\r\n        }\r\n\r\n        c = this._peekCharacter();\r\n      } while (c && textCharacterRegExp.test(c));\r\n\r\n      return new Token(TokenKind.Text, input.getNewRange(startIndex, this._currentIndex), text);\r\n    }\r\n\r\n    // Is it a dollar variable?  The valid environment variable names are [A-Z_][A-Z0-9_]*\r\n    if (firstChar === '$') {\r\n      this._readCharacter();\r\n\r\n      let name: string = this._readCharacter() || '';\r\n      if (!startVariableCharacterRegExp.test(name)) {\r\n        throw new ParseError(\r\n          'The \"$\" symbol must be followed by a letter or underscore',\r\n          input.getNewRange(startIndex, this._currentIndex)\r\n        );\r\n      }\r\n\r\n      let c: string | undefined = this._peekCharacter();\r\n      while (c && variableCharacterRegExp.test(c)) {\r\n        name += this._readCharacter();\r\n        c = this._peekCharacter();\r\n      }\r\n      return new Token(TokenKind.DollarVariable, input.getNewRange(startIndex, this._currentIndex), name);\r\n    }\r\n\r\n    // Is it the \"&&\" token?\r\n    if (firstChar === '&') {\r\n      if (this._peekCharacterAfter() === '&') {\r\n        this._readCharacter();\r\n        this._readCharacter();\r\n        return new Token(TokenKind.AndIf, input.getNewRange(startIndex, this._currentIndex));\r\n      }\r\n    }\r\n\r\n    // Otherwise treat it as an \"other\" character\r\n    this._readCharacter();\r\n    return new Token(TokenKind.OtherCharacter, input.getNewRange(startIndex, this._currentIndex));\r\n  }\r\n\r\n  public readTokens(): Token[] {\r\n    const tokens: Token[] = [];\r\n    let token: Token = this.readToken();\r\n    while (token.kind !== TokenKind.EndOfInput) {\r\n      tokens.push(token);\r\n      token = this.readToken();\r\n    }\r\n    return tokens;\r\n  }\r\n\r\n  /**\r\n   * Retrieve the next character in the input stream.\r\n   * @returns a string of length 1, or undefined if the end of input is reached\r\n   */\r\n  private _readCharacter(): string | undefined {\r\n    if (this._currentIndex >= this.input.end) {\r\n      return undefined;\r\n    }\r\n    return this.input.buffer[this._currentIndex++];\r\n  }\r\n\r\n  /**\r\n   * Return the next character in the input stream, but don't advance the stream pointer.\r\n   * @returns a string of length 1, or undefined if the end of input is reached\r\n   */\r\n  private _peekCharacter(): string | undefined {\r\n    if (this._currentIndex >= this.input.end) {\r\n      return undefined;\r\n    }\r\n    return this.input.buffer[this._currentIndex];\r\n  }\r\n\r\n  /**\r\n   * Return the character after the next character in the input stream, but don't advance the stream pointer.\r\n   * @returns a string of length 1, or undefined if the end of input is reached\r\n   */\r\n  private _peekCharacterAfter(): string | undefined {\r\n    if (this._currentIndex + 1 >= this.input.end) {\r\n      return undefined;\r\n    }\r\n    return this.input.buffer[this._currentIndex + 1];\r\n  }\r\n}\r\n"]}