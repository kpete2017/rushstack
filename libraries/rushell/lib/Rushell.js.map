{"version":3,"file":"Rushell.js","sourceRoot":"","sources":["../src/Rushell.ts"],"names":[],"mappings":";AAAA,4FAA4F;AAC5F,2DAA2D;;;AAG3D,oEAA0D;AAC1D,qCAAkC;AAElC,2CAAwC;AAExC,6CAA0C;AAa1C;;;GAGG;AACH,MAAa,OAAO;IACX,OAAO,CAAC,MAAc;QAC3B,MAAM,SAAS,GAAc,IAAI,qBAAS,CAAC,MAAM,CAAC,CAAC;QACnD,MAAM,MAAM,GAAW,IAAI,eAAM,CAAC,SAAS,CAAC,CAAC;QAC7C,MAAM,SAAS,GAAc,MAAM,CAAC,KAAK,EAAE,CAAC;QAE5C,OAAO,IAAI,CAAC,aAAa,CAAC,SAAS,CAAC,CAAC;IACvC,CAAC;IAEO,aAAa,CAAC,OAAgB;QACpC,QAAQ,OAAO,CAAC,IAAI,EAAE;YACpB;gBACE,OAAO,EAAE,KAAK,EAAE,OAAO,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,EAAE,CAAC,EAAE,CAAC;YACnF;gBACE,OAAO,EAAE,KAAK,EAAE,OAAO,CAAC,KAAM,CAAC,KAAK,CAAC,QAAQ,EAAE,EAAE,CAAC;YACpD;gBACE,IAAI,OAAO,CAAC,IAAI,EAAE;oBAChB,OAAO,IAAI,CAAC,aAAa,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;iBACzC;gBACD,MAAM;YACR;gBACE,OAAO,IAAI,CAAC,gBAAgB,CAAC,OAAO,CAAC,CAAC;YACxC;gBACE,MAAM,IAAI,uBAAU,CAAC,8BAA8B,GAAG,OAAO,CAAC,IAAI,EAAE,OAAO,CAAC,YAAY,EAAE,CAAC,CAAC;SAC/F;QACD,OAAO,EAAE,KAAK,EAAE,EAAE,EAAE,CAAC;IACvB,CAAC;IAEO,gBAAgB,CAAC,UAAsB;QAC7C,IAAI,CAAC,UAAU,CAAC,WAAW,EAAE;YAC3B,MAAM,IAAI,uBAAU,CAAC,sBAAsB,EAAE,UAAU,CAAC,YAAY,EAAE,CAAC,CAAC;SACzE;QAED,MAAM,iBAAiB,GAA0B,IAAI,CAAC,aAAa,CAAC,UAAU,CAAC,WAAW,CAAC,CAAC;QAC5F,MAAM,iBAAiB,GAA4B,EAAE,CAAC;QACtD,KAAK,IAAI,CAAC,GAAW,CAAC,EAAE,CAAC,GAAG,UAAU,CAAC,SAAS,CAAC,MAAM,EAAE,EAAE,CAAC,EAAE;YAC5D,iBAAiB,CAAC,IAAI,CAAC,IAAI,CAAC,aAAa,CAAC,UAAU,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;SACrE;QAED,MAAM,WAAW,GAAW,iBAAiB,CAAC,KAAK,CAAC;QACpD,MAAM,WAAW,GAAa,iBAAiB,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC;QAEpE,MAAM,MAAM,GAA2C,8BAAU,CAAC,SAAS,CAAC,WAAW,EAAE,WAAW,CAAC,CAAC;QAEtG,OAAO,EAAE,KAAK,EAAE,MAAM,CAAC,MAAM,EAAE,CAAC;IAClC,CAAC;CACF;AA9CD,0BA8CC","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport * as child_process from 'child_process';\r\nimport { Executable } from '@rushstack/node-core-library';\r\nimport { Parser } from './Parser';\r\n\r\nimport { Tokenizer } from './Tokenizer';\r\nimport { AstNode, AstScript, AstKind, AstCommand } from './AstNode';\r\nimport { ParseError } from './ParseError';\r\n\r\n/**\r\n * The returned value for {@link Rushell.execute}.\r\n * @beta\r\n */\r\nexport interface IRushellExecuteResult {\r\n  /**\r\n   * A text value that was the result of evaluating the script expression.\r\n   */\r\n  value: string;\r\n}\r\n\r\n/**\r\n * The shell command interpreter.\r\n * @beta\r\n */\r\nexport class Rushell {\r\n  public execute(script: string): IRushellExecuteResult {\r\n    const tokenizer: Tokenizer = new Tokenizer(script);\r\n    const parser: Parser = new Parser(tokenizer);\r\n    const astScript: AstScript = parser.parse();\r\n\r\n    return this._evaluateNode(astScript);\r\n  }\r\n\r\n  private _evaluateNode(astNode: AstNode): IRushellExecuteResult {\r\n    switch (astNode.kind) {\r\n      case AstKind.CompoundWord:\r\n        return { value: astNode.parts.map((x) => this._evaluateNode(x).value).join('') };\r\n      case AstKind.Text:\r\n        return { value: astNode.token!.range.toString() };\r\n      case AstKind.Script:\r\n        if (astNode.body) {\r\n          return this._evaluateNode(astNode.body);\r\n        }\r\n        break;\r\n      case AstKind.Command:\r\n        return this._evaluateCommand(astNode);\r\n      default:\r\n        throw new ParseError('Unsupported operation type: ' + astNode.kind, astNode.getFullRange());\r\n    }\r\n    return { value: '' };\r\n  }\r\n\r\n  private _evaluateCommand(astCommand: AstCommand): IRushellExecuteResult {\r\n    if (!astCommand.commandPath) {\r\n      throw new ParseError('Missing command path', astCommand.getFullRange());\r\n    }\r\n\r\n    const commandPathResult: IRushellExecuteResult = this._evaluateNode(astCommand.commandPath);\r\n    const commandArgResults: IRushellExecuteResult[] = [];\r\n    for (let i: number = 0; i < astCommand.arguments.length; ++i) {\r\n      commandArgResults.push(this._evaluateNode(astCommand.arguments[i]));\r\n    }\r\n\r\n    const commandPath: string = commandPathResult.value;\r\n    const commandArgs: string[] = commandArgResults.map((x) => x.value);\r\n\r\n    const result: child_process.SpawnSyncReturns<string> = Executable.spawnSync(commandPath, commandArgs);\r\n\r\n    return { value: result.stdout };\r\n  }\r\n}\r\n"]}