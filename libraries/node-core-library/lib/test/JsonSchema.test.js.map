{"version":3,"file":"JsonSchema.test.js","sourceRoot":"","sources":["../../src/test/JsonSchema.test.ts"],"names":[],"mappings":";AAAA,4FAA4F;AAC5F,2DAA2D;;;;;;;;;;;;;;;;;;;;;AAE3D,2CAA6B;AAC7B,0CAAmD;AACnD,8CAAiE;AAEjE,SAAS,SAAS,CAAC,IAAY;IAC7B,OAAO,IAAI,CAAC,OAAO,CAAC,WAAW,EAAE,GAAG,CAAC,CAAC,IAAI,EAAE,CAAC;AAC/C,CAAC;AAED,QAAQ,CAAC,YAAY,EAAE,GAAG,EAAE;IAC1B,MAAM,UAAU,GAAW,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE,8BAA8B,CAAC,CAAC,CAAC;IAE9F,MAAM,MAAM,GAAe,uBAAU,CAAC,QAAQ,CAAC,UAAU,CAAC,CAAC;IAE3D,IAAI,CAAC,oDAAoD,EAAE,GAAG,EAAE;QAC9D,MAAM,QAAQ,GAAW,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE,uBAAuB,CAAC,CAAC,CAAC;QACrF,MAAM,UAAU,GAAe,mBAAQ,CAAC,eAAe,CAAC,QAAQ,EAAE,MAAM,CAAC,CAAC;QAC1E,MAAM,CAAC,UAAU,CAAC,CAAC,aAAa,CAAC;YAC/B,aAAa,EAAE,kBAAkB;YACjC,YAAY,EAAE,CAAC,OAAO,EAAE,QAAQ,EAAE,SAAS,CAAC;SAC7C,CAAC,CAAC;IACL,CAAC,CAAC,CAAC;IAEH,IAAI,CAAC,6EAA6E,EAAE,GAAG,EAAE;QACvF,MAAM,SAAS,GAAW,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE,wBAAwB,CAAC,CAAC,CAAC;QACvF,MAAM,WAAW,GAAe,mBAAQ,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;QAEzD,MAAM,aAAa,GAAW;;;;;;wCAMM,CAAC;QAErC,IAAI,UAAU,GAAW,CAAC,CAAC;QAE3B,MAAM,CAAC,0BAA0B,CAAC,WAAW,EAAE,CAAC,SAA+B,EAAE,EAAE;YACjF,EAAE,UAAU,CAAC;YACb,MAAM,CAAC,SAAS,CAAC,SAAS,CAAC,OAAO,CAAC,CAAC,CAAC,OAAO,CAAC,SAAS,CAAC,aAAa,CAAC,CAAC,CAAC;QACzE,CAAC,CAAC,CAAC;QAEH,MAAM,CAAC,UAAU,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;IAChC,CAAC,CAAC,CAAC;AACL,CAAC,CAAC,CAAC","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport * as path from 'path';\r\nimport { JsonFile, JsonObject } from '../JsonFile';\r\nimport { JsonSchema, IJsonSchemaErrorInfo } from '../JsonSchema';\r\n\r\nfunction normalize(text: string): string {\r\n  return text.replace(/[\\r\\n ]+/g, ' ').trim();\r\n}\r\n\r\ndescribe('JsonSchema', () => {\r\n  const schemaPath: string = path.resolve(path.join(__dirname, './test-data/test-schema.json'));\r\n\r\n  const schema: JsonSchema = JsonSchema.fromFile(schemaPath);\r\n\r\n  test('loadAndValidate successfully validates a JSON file', () => {\r\n    const jsonPath: string = path.resolve(path.join(__dirname, './test-data/test.json'));\r\n    const jsonObject: JsonObject = JsonFile.loadAndValidate(jsonPath, schema);\r\n    expect(jsonObject).toMatchObject({\r\n      exampleString: 'This is a string',\r\n      exampleArray: ['apple', 'banana', 'coconut']\r\n    });\r\n  });\r\n\r\n  test('validateObjectWithCallback successfully reports a compound validation error', () => {\r\n    const jsonPath2: string = path.resolve(path.join(__dirname, './test-data/test2.json'));\r\n    const jsonObject2: JsonObject = JsonFile.load(jsonPath2);\r\n\r\n    const expectedError: string = `\r\nError: #/exampleOneOf (Description for exampleOneOf - this i...)\r\n    Data does not match any schemas from 'oneOf'\r\nError: #/exampleOneOf (Description for type1)\r\n      Additional properties not allowed: field2\r\nError: #/exampleOneOf (Description for type2)\r\n      Missing required property: field3`;\r\n\r\n    let errorCount: number = 0;\r\n\r\n    schema.validateObjectWithCallback(jsonObject2, (errorInfo: IJsonSchemaErrorInfo) => {\r\n      ++errorCount;\r\n      expect(normalize(errorInfo.details)).toEqual(normalize(expectedError));\r\n    });\r\n\r\n    expect(errorCount).toEqual(1);\r\n  });\r\n});\r\n"]}