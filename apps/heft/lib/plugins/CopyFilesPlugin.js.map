{"version":3,"file":"CopyFilesPlugin.js","sourceRoot":"","sources":["../../src/plugins/CopyFilesPlugin.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport * as chokidar from 'chokidar';\r\nimport * as path from 'path';\r\nimport glob from 'fast-glob';\r\nimport { performance } from 'perf_hooks';\r\nimport { AlreadyExistsBehavior, FileSystem } from '@rushstack/node-core-library';\r\n\r\nimport { ScopedLogger } from '../pluginFramework/logging/ScopedLogger';\r\nimport { HeftEventPluginBase } from '../pluginFramework/HeftEventPluginBase';\r\nimport { HeftSession } from '../pluginFramework/HeftSession';\r\nimport { HeftConfiguration } from '../configuration/HeftConfiguration';\r\nimport {\r\n  IExtendedSharedCopyConfiguration,\r\n  IHeftEventActions,\r\n  IHeftConfigurationCopyFilesEventAction,\r\n  HeftEvent\r\n} from '../utilities/CoreConfigFiles';\r\nimport { IBuildStageProperties } from '../stages/BuildStage';\r\nimport { Async } from '../utilities/Async';\r\nimport { Constants } from '../utilities/Constants';\r\n\r\ninterface ICopyFileDescriptor {\r\n  sourceFilePath: string;\r\n  destinationFilePath: string;\r\n  hardlink: boolean;\r\n}\r\n\r\nexport interface IResolvedDestinationCopyConfiguration extends IExtendedSharedCopyConfiguration {\r\n  /**\r\n   * Fully-qualified folder paths to which files should be copied.\r\n   */\r\n  resolvedDestinationFolderPaths: string[];\r\n}\r\n\r\nexport interface ICopyFilesOptions {\r\n  buildFolder: string;\r\n  copyConfigurations: IResolvedDestinationCopyConfiguration[];\r\n  logger: ScopedLogger;\r\n  watchMode: boolean;\r\n}\r\n\r\nexport interface ICopyFilesResult {\r\n  copiedFileCount: number;\r\n  linkedFileCount: number;\r\n}\r\n\r\nexport class CopyFilesPlugin extends HeftEventPluginBase<IHeftConfigurationCopyFilesEventAction> {\r\n  public readonly pluginName: string = 'CopyFilesPlugin';\r\n  protected eventActionName: keyof IHeftEventActions = 'copyFiles';\r\n  protected loggerName: string = 'copy-files';\r\n\r\n  /**\r\n   * @override\r\n   */\r\n  protected async handleBuildEventActionsAsync(\r\n    heftEvent: HeftEvent,\r\n    heftEventActions: IHeftConfigurationCopyFilesEventAction[],\r\n    logger: ScopedLogger,\r\n    heftSession: HeftSession,\r\n    heftConfiguration: HeftConfiguration,\r\n    properties: IBuildStageProperties\r\n  ): Promise<void> {\r\n    await this._runCopyFilesForHeftEventActions(heftEventActions, logger, heftConfiguration);\r\n  }\r\n\r\n  private async _runCopyFilesForHeftEventActions(\r\n    heftEventActions: IHeftConfigurationCopyFilesEventAction[],\r\n    logger: ScopedLogger,\r\n    heftConfiguration: HeftConfiguration\r\n  ): Promise<void> {\r\n    const copyConfigurations: IResolvedDestinationCopyConfiguration[] = [];\r\n    for (const copyFilesEventAction of heftEventActions) {\r\n      for (const copyOperation of copyFilesEventAction.copyOperations) {\r\n        copyConfigurations.push({\r\n          ...copyOperation,\r\n          resolvedDestinationFolderPaths: copyOperation.destinationFolders.map((destinationFolder) =>\r\n            path.join(heftConfiguration.buildFolder, destinationFolder)\r\n          )\r\n        });\r\n      }\r\n    }\r\n\r\n    await this.runCopyAsync({\r\n      buildFolder: heftConfiguration.buildFolder,\r\n      copyConfigurations,\r\n      logger,\r\n      watchMode: false\r\n    });\r\n  }\r\n\r\n  protected async runCopyAsync(options: ICopyFilesOptions): Promise<void> {\r\n    const { logger, buildFolder, copyConfigurations } = options;\r\n\r\n    const startTime: number = performance.now();\r\n    const copyDescriptors: ICopyFileDescriptor[] = await this._getCopyFileDescriptorsAsync(\r\n      buildFolder,\r\n      copyConfigurations\r\n    );\r\n\r\n    if (copyDescriptors.length === 0) {\r\n      // No need to run copy and print to console\r\n      return;\r\n    }\r\n\r\n    const { copiedFileCount, linkedFileCount } = await this._copyFilesAsync(copyDescriptors);\r\n    const duration: number = performance.now() - startTime;\r\n    logger.terminal.writeLine(\r\n      `Copied ${copiedFileCount} file${copiedFileCount === 1 ? '' : 's'} and ` +\r\n        `linked ${linkedFileCount} file${linkedFileCount === 1 ? '' : 's'} in ${Math.round(duration)}ms`\r\n    );\r\n\r\n    // Then enter watch mode if requested\r\n    if (options.watchMode) {\r\n      Async.runWatcherWithErrorHandling(async () => await this._runWatchAsync(options), logger);\r\n    }\r\n  }\r\n\r\n  private async _copyFilesAsync(copyDescriptors: ICopyFileDescriptor[]): Promise<ICopyFilesResult> {\r\n    if (copyDescriptors.length === 0) {\r\n      return { copiedFileCount: 0, linkedFileCount: 0 };\r\n    }\r\n\r\n    let copiedFileCount: number = 0;\r\n    let linkedFileCount: number = 0;\r\n    await Async.forEachLimitAsync(\r\n      copyDescriptors,\r\n      Constants.maxParallelism,\r\n      async (copyDescriptor: ICopyFileDescriptor) => {\r\n        if (copyDescriptor.hardlink) {\r\n          linkedFileCount++;\r\n          await FileSystem.createHardLinkAsync({\r\n            linkTargetPath: copyDescriptor.sourceFilePath,\r\n            newLinkPath: copyDescriptor.destinationFilePath,\r\n            alreadyExistsBehavior: AlreadyExistsBehavior.Overwrite\r\n          });\r\n        } else {\r\n          copiedFileCount++;\r\n          await FileSystem.copyFileAsync({\r\n            sourcePath: copyDescriptor.sourceFilePath,\r\n            destinationPath: copyDescriptor.destinationFilePath,\r\n            alreadyExistsBehavior: AlreadyExistsBehavior.Overwrite\r\n          });\r\n        }\r\n      }\r\n    );\r\n\r\n    return {\r\n      copiedFileCount,\r\n      linkedFileCount\r\n    };\r\n  }\r\n\r\n  private async _getCopyFileDescriptorsAsync(\r\n    buildFolder: string,\r\n    copyConfigurations: IResolvedDestinationCopyConfiguration[]\r\n  ): Promise<ICopyFileDescriptor[]> {\r\n    const processedCopyDescriptors: ICopyFileDescriptor[] = [];\r\n\r\n    // Create a map to deduplicate and prevent double-writes\r\n    // resolvedDestinationFilePath -> descriptor\r\n    const destinationCopyDescriptors: Map<string, ICopyFileDescriptor> = new Map();\r\n\r\n    for (const copyConfiguration of copyConfigurations) {\r\n      // Resolve the source folder path which is where the glob will be run from\r\n      const resolvedSourceFolderPath: string = path.resolve(buildFolder, copyConfiguration.sourceFolder);\r\n      const sourceFileRelativePaths: Set<string> = new Set<string>(\r\n        await glob(this._getIncludedGlobPatterns(copyConfiguration), {\r\n          cwd: resolvedSourceFolderPath,\r\n          ignore: copyConfiguration.excludeGlobs,\r\n          dot: true,\r\n          onlyFiles: true\r\n        })\r\n      );\r\n\r\n      // Dedupe and throw if a double-write is detected\r\n      for (const destinationFolderPath of copyConfiguration.resolvedDestinationFolderPaths) {\r\n        for (const sourceFileRelativePath of sourceFileRelativePaths) {\r\n          // Only include the relative path from the sourceFolder if flatten is false\r\n          const resolvedSourceFilePath: string = path.join(resolvedSourceFolderPath, sourceFileRelativePath);\r\n          const resolvedDestinationFilePath: string = path.resolve(\r\n            destinationFolderPath,\r\n            copyConfiguration.flatten ? '.' : path.dirname(sourceFileRelativePath),\r\n            path.basename(sourceFileRelativePath)\r\n          );\r\n\r\n          // Throw if a duplicate copy target with a different source or options is specified\r\n          const existingDestinationCopyDescriptor: ICopyFileDescriptor | undefined =\r\n            destinationCopyDescriptors.get(resolvedDestinationFilePath);\r\n          if (existingDestinationCopyDescriptor) {\r\n            if (\r\n              existingDestinationCopyDescriptor.sourceFilePath === resolvedSourceFilePath &&\r\n              existingDestinationCopyDescriptor.hardlink === !!copyConfiguration.hardlink\r\n            ) {\r\n              // Found a duplicate, avoid adding again\r\n              continue;\r\n            }\r\n            throw new Error(\r\n              `Cannot copy different files to the same destination \"${resolvedDestinationFilePath}\"`\r\n            );\r\n          }\r\n\r\n          // Finally, default hardlink to false, add to the result, and add to the map for deduping\r\n          const processedCopyDescriptor: ICopyFileDescriptor = {\r\n            sourceFilePath: resolvedSourceFilePath,\r\n            destinationFilePath: resolvedDestinationFilePath,\r\n            hardlink: !!copyConfiguration.hardlink\r\n          };\r\n          processedCopyDescriptors.push(processedCopyDescriptor);\r\n          destinationCopyDescriptors.set(resolvedDestinationFilePath, processedCopyDescriptor);\r\n        }\r\n      }\r\n    }\r\n\r\n    // We're done with the map, grab the values and return\r\n    return processedCopyDescriptors;\r\n  }\r\n\r\n  private _getIncludedGlobPatterns(copyConfiguration: IExtendedSharedCopyConfiguration): string[] {\r\n    const patternsToGlob: Set<string> = new Set<string>();\r\n\r\n    // Glob file extensions with a specific glob to increase perf\r\n    const escapedFileExtensions: Set<string> = new Set<string>();\r\n    for (const fileExtension of copyConfiguration.fileExtensions || []) {\r\n      let escapedFileExtension: string;\r\n      if (fileExtension.charAt(0) === '.') {\r\n        escapedFileExtension = fileExtension.substr(1);\r\n      } else {\r\n        escapedFileExtension = fileExtension;\r\n      }\r\n\r\n      escapedFileExtension = glob.escapePath(escapedFileExtension);\r\n      escapedFileExtensions.add(escapedFileExtension);\r\n    }\r\n\r\n    if (escapedFileExtensions.size > 1) {\r\n      patternsToGlob.add(`**/*.{${Array.from(escapedFileExtensions).join(',')}}`);\r\n    } else if (escapedFileExtensions.size === 1) {\r\n      patternsToGlob.add(`**/*.${Array.from(escapedFileExtensions)[0]}`);\r\n    }\r\n\r\n    // Now include the other globs as well\r\n    for (const include of copyConfiguration.includeGlobs || []) {\r\n      patternsToGlob.add(include);\r\n    }\r\n\r\n    return Array.from(patternsToGlob);\r\n  }\r\n\r\n  private async _runWatchAsync(options: ICopyFilesOptions): Promise<void> {\r\n    const { buildFolder, copyConfigurations, logger } = options;\r\n\r\n    for (const copyConfiguration of copyConfigurations) {\r\n      // Obtain the glob patterns to provide to the watcher\r\n      const globsToWatch: string[] = this._getIncludedGlobPatterns(copyConfiguration);\r\n      if (globsToWatch.length) {\r\n        const resolvedSourceFolderPath: string = path.join(buildFolder, copyConfiguration.sourceFolder);\r\n\r\n        const watcher: chokidar.FSWatcher = chokidar.watch(globsToWatch, {\r\n          cwd: resolvedSourceFolderPath,\r\n          ignoreInitial: true,\r\n          ignored: copyConfiguration.excludeGlobs\r\n        });\r\n\r\n        const copyAsset: (relativeAssetPath: string) => Promise<void> = async (relativeAssetPath: string) => {\r\n          const { copiedFileCount, linkedFileCount } = await this._copyFilesAsync(\r\n            copyConfiguration.resolvedDestinationFolderPaths.map((resolvedDestinationFolderPath) => {\r\n              return {\r\n                sourceFilePath: path.join(resolvedSourceFolderPath, relativeAssetPath),\r\n                destinationFilePath: path.join(\r\n                  resolvedDestinationFolderPath,\r\n                  copyConfiguration.flatten ? path.basename(relativeAssetPath) : relativeAssetPath\r\n                ),\r\n                hardlink: !!copyConfiguration.hardlink\r\n              };\r\n            })\r\n          );\r\n          logger.terminal.writeLine(\r\n            copyConfiguration.hardlink\r\n              ? `Linked ${linkedFileCount} file${linkedFileCount === 1 ? '' : 's'}`\r\n              : `Copied ${copiedFileCount} file${copiedFileCount === 1 ? '' : 's'}`\r\n          );\r\n        };\r\n\r\n        const deleteAsset: (relativeAssetPath: string) => Promise<void> = async (relativeAssetPath) => {\r\n          const deletePromises: Promise<void>[] = copyConfiguration.resolvedDestinationFolderPaths.map(\r\n            (resolvedDestinationFolderPath) =>\r\n              FileSystem.deleteFileAsync(path.resolve(resolvedDestinationFolderPath, relativeAssetPath))\r\n          );\r\n          await Promise.all(deletePromises);\r\n          logger.terminal.writeLine(\r\n            `Deleted ${deletePromises.length} file${deletePromises.length === 1 ? '' : 's'}`\r\n          );\r\n        };\r\n\r\n        watcher.on('add', copyAsset);\r\n        watcher.on('change', copyAsset);\r\n        watcher.on('unlink', deleteAsset);\r\n      }\r\n    }\r\n\r\n    return new Promise(() => {\r\n      /* never resolve */\r\n    });\r\n  }\r\n}\r\n"]}