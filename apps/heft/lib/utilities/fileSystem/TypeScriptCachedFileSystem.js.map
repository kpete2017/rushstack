{"version":3,"file":"TypeScriptCachedFileSystem.js","sourceRoot":"","sources":["../../../src/utilities/fileSystem/TypeScriptCachedFileSystem.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport * as fs from 'fs';\r\nimport {\r\n  Encoding,\r\n  Text,\r\n  IFileSystemWriteFileOptions,\r\n  IFileSystemReadFileOptions,\r\n  IFileSystemCopyFileOptions,\r\n  IFileSystemDeleteFileOptions,\r\n  IFileSystemCreateLinkOptions,\r\n  FileSystem,\r\n  FileSystemStats,\r\n  Sort\r\n} from '@rushstack/node-core-library';\r\n\r\nexport interface IReadFolderFilesAndDirectoriesResult {\r\n  files: string[];\r\n  directories: string[];\r\n}\r\n\r\ninterface ICacheEntry<TEntry> {\r\n  entry: TEntry | undefined;\r\n  error?: NodeJS.ErrnoException;\r\n}\r\n\r\n/**\r\n * This is a FileSystem API (largely unrelated to the @rushstack/node-core-library FileSystem API)\r\n * that provides caching to the Heft TypeScriptBuilder.\r\n * It uses an in-memory cache to avoid requests against the disk. It assumes that the disk stays\r\n * static after construction, except for writes performed through the TypeScriptCachedFileSystem\r\n * instance.\r\n */\r\nexport class TypeScriptCachedFileSystem {\r\n  private _statsCache: Map<string, ICacheEntry<FileSystemStats>> = new Map();\r\n  private _readFolderCache: Map<string, ICacheEntry<IReadFolderFilesAndDirectoriesResult>> = new Map();\r\n  private _readFileCache: Map<string, ICacheEntry<Buffer>> = new Map();\r\n  private _realPathCache: Map<string, ICacheEntry<string>> = new Map();\r\n\r\n  public exists: (path: string) => boolean = (path: string) => {\r\n    try {\r\n      this.getStatistics(path);\r\n      return true;\r\n    } catch (e) {\r\n      if (FileSystem.isNotExistError(e)) {\r\n        return false;\r\n      } else {\r\n        throw e;\r\n      }\r\n    }\r\n  };\r\n\r\n  public getStatistics: (path: string) => FileSystemStats = (path: string) => {\r\n    return this._withCaching(path, FileSystem.getStatistics, this._statsCache);\r\n  };\r\n\r\n  public ensureFolder: (folderPath: string) => void = (folderPath: string) => {\r\n    if (!this._readFolderCache.get(folderPath)?.entry && !this._statsCache.get(folderPath)?.entry) {\r\n      FileSystem.ensureFolder(folderPath);\r\n      this._invalidateCacheEntry(folderPath);\r\n    }\r\n  };\r\n\r\n  public ensureFolderAsync: (folderPath: string) => Promise<void> = async (folderPath: string) => {\r\n    if (!this._readFolderCache.get(folderPath)?.entry && !this._statsCache.get(folderPath)?.entry) {\r\n      await FileSystem.ensureFolderAsync(folderPath);\r\n      this._invalidateCacheEntry(folderPath);\r\n    }\r\n  };\r\n\r\n  public writeFile: (\r\n    filePath: string,\r\n    contents: string | Buffer,\r\n    options?: IFileSystemWriteFileOptions | undefined\r\n  ) => void = (\r\n    filePath: string,\r\n    contents: string | Buffer,\r\n    options?: IFileSystemWriteFileOptions | undefined\r\n  ) => {\r\n    FileSystem.writeFile(filePath, contents, options);\r\n    this._invalidateCacheEntry(filePath);\r\n  };\r\n\r\n  public readFile: (filePath: string, options?: IFileSystemReadFileOptions | undefined) => string = (\r\n    filePath: string,\r\n    options?: IFileSystemReadFileOptions | undefined\r\n  ) => {\r\n    let contents: string = this.readFileToBuffer(filePath).toString(options?.encoding || Encoding.Utf8);\r\n    if (options?.convertLineEndings) {\r\n      contents = Text.convertTo(contents, options.convertLineEndings);\r\n    }\r\n\r\n    return contents;\r\n  };\r\n\r\n  public readFileToBuffer: (filePath: string) => Buffer = (filePath: string) => {\r\n    return this._withCaching(filePath, FileSystem.readFileToBuffer, this._readFileCache);\r\n  };\r\n\r\n  public copyFileAsync: (options: IFileSystemCopyFileOptions) => Promise<void> = async (\r\n    options: IFileSystemCopyFileOptions\r\n  ) => {\r\n    await FileSystem.copyFileAsync(options);\r\n    this._invalidateCacheEntry(options.destinationPath);\r\n  };\r\n\r\n  public deleteFile: (filePath: string, options?: IFileSystemDeleteFileOptions | undefined) => void = (\r\n    filePath: string,\r\n    options?: IFileSystemDeleteFileOptions | undefined\r\n  ) => {\r\n    const cachedError: Error | undefined = this._statsCache.get(filePath)?.error;\r\n    if (!cachedError || !FileSystem.isFileDoesNotExistError(cachedError)) {\r\n      FileSystem.deleteFile(filePath);\r\n      this._invalidateCacheEntry(filePath);\r\n    } else if (options?.throwIfNotExists) {\r\n      throw cachedError;\r\n    }\r\n  };\r\n\r\n  public createHardLinkAsync: (options: IFileSystemCreateLinkOptions) => Promise<void> = async (\r\n    options: IFileSystemCreateLinkOptions\r\n  ) => {\r\n    await FileSystem.createHardLinkAsync(options);\r\n    this._invalidateCacheEntry(options.newLinkPath);\r\n  };\r\n\r\n  public getRealPath: (linkPath: string) => string = (linkPath: string) => {\r\n    return this._withCaching(linkPath, FileSystem.getRealPath, this._realPathCache);\r\n  };\r\n\r\n  public readFolderFilesAndDirectories: (folderPath: string) => IReadFolderFilesAndDirectoriesResult = (\r\n    folderPath: string\r\n  ) => {\r\n    return this._withCaching(\r\n      folderPath,\r\n      (path: string) => {\r\n        // TODO: Replace this with a FileSystem API\r\n        const folderEntries: fs.Dirent[] = fs.readdirSync(path, { withFileTypes: true });\r\n        return this._sortFolderEntries(folderEntries);\r\n      },\r\n      this._readFolderCache\r\n    );\r\n  };\r\n\r\n  private _sortFolderEntries(folderEntries: fs.Dirent[]): IReadFolderFilesAndDirectoriesResult {\r\n    // TypeScript expects entries sorted ordinally by name\r\n    // In practice this might not matter\r\n    folderEntries.sort((a, b) => Sort.compareByValue(a, b));\r\n\r\n    const files: string[] = [];\r\n    const directories: string[] = [];\r\n    for (const folderEntry of folderEntries) {\r\n      if (folderEntry.isFile()) {\r\n        files.push(folderEntry.name);\r\n      } else if (folderEntry.isDirectory()) {\r\n        directories.push(folderEntry.name);\r\n      }\r\n    }\r\n\r\n    return { files, directories };\r\n  }\r\n\r\n  private _withCaching<TResult>(\r\n    path: string,\r\n    fn: (path: string) => TResult,\r\n    cache: Map<string, ICacheEntry<TResult>>\r\n  ): TResult {\r\n    let cacheEntry: ICacheEntry<TResult> | undefined = cache.get(path);\r\n    if (!cacheEntry) {\r\n      try {\r\n        cacheEntry = { entry: fn(path) };\r\n      } catch (e) {\r\n        cacheEntry = { error: e, entry: undefined };\r\n      }\r\n\r\n      cache.set(path, cacheEntry);\r\n    }\r\n\r\n    if (cacheEntry.entry) {\r\n      return cacheEntry.entry;\r\n    } else {\r\n      throw cacheEntry.error;\r\n    }\r\n  }\r\n\r\n  private _invalidateCacheEntry(path: string): void {\r\n    this._statsCache.delete(path);\r\n    this._readFolderCache.delete(path);\r\n    this._readFileCache.delete(path);\r\n    this._realPathCache.delete(path);\r\n  }\r\n}\r\n"]}