{"version":3,"file":"SubprocessTerminator.js","sourceRoot":"","sources":["../../../src/utilities/subprocess/SubprocessTerminator.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport { Executable } from '@rushstack/node-core-library';\r\nimport * as child_process from 'child_process';\r\nimport process from 'process';\r\n\r\ndeclare module 'child_process' {\r\n  /* eslint-disable */\r\n  interface ChildProcess {\r\n    exitCode?: number | null;\r\n  }\r\n  /* eslint-enable */\r\n}\r\n\r\n/**\r\n * Details about how the `child_process.ChildProcess` was created.\r\n */\r\nexport interface ISubprocessOptions {\r\n  detached: boolean;\r\n}\r\n\r\ninterface ITrackedSubprocess {\r\n  subprocess: child_process.ChildProcess;\r\n  subprocessOptions: ISubprocessOptions;\r\n}\r\n\r\n/**\r\n * When a child process is created, registering it with the SubprocessTerminator will ensure\r\n * that the child gets terminated when the current process terminates.\r\n *\r\n * @remarks\r\n * This works by hooking the current process's events for SIGTERM/SIGINT/exit, and ensuring the\r\n * child process gets terminated in those cases.\r\n *\r\n * SubprocessTerminator doesn't do anything on Windows, since by default Windows automatically\r\n * terminates child processes when their parent is terminated.\r\n */\r\nexport class SubprocessTerminator {\r\n  /**\r\n   * Whether the hooks are installed\r\n   */\r\n  private static _initialized: boolean = false;\r\n\r\n  /**\r\n   * The list of registered child processes.  Processes are removed from this set if they\r\n   * terminate on their own.\r\n   */\r\n  private static _subprocessesByPid: Map<number, ITrackedSubprocess> = new Map();\r\n\r\n  private static readonly _isWindows: boolean = process.platform === 'win32';\r\n\r\n  public static readonly RECOMMENDED_OPTIONS: ISubprocessOptions = {\r\n    // On POSIX systems, detached=true is required for killing the subtree.\r\n    // On Windows, detached=true creates a separate console window which is generally not what we want\r\n    detached: process.platform !== 'win32'\r\n  };\r\n\r\n  /**\r\n   * Registers a child process so that it will be terminated automatically if the current process\r\n   * is terminated.\r\n   */\r\n  public static killProcessTreeOnExit(\r\n    subprocess: child_process.ChildProcess,\r\n    subprocessOptions: ISubprocessOptions\r\n  ): void {\r\n    if (typeof subprocess.exitCode === 'number') {\r\n      // Process has already been killed\r\n      return;\r\n    }\r\n\r\n    SubprocessTerminator._validateSubprocessOptions(subprocessOptions);\r\n\r\n    SubprocessTerminator._ensureInitialized();\r\n\r\n    // Closure variable\r\n    const pid: number = subprocess.pid;\r\n\r\n    subprocess.on('close', (code: number, signal: string): void => {\r\n      if (SubprocessTerminator._subprocessesByPid.has(pid)) {\r\n        SubprocessTerminator._logDebug(`untracking #${pid}`);\r\n        SubprocessTerminator._subprocessesByPid.delete(pid);\r\n      }\r\n    });\r\n    SubprocessTerminator._subprocessesByPid.set(pid, {\r\n      subprocess,\r\n      subprocessOptions\r\n    });\r\n\r\n    SubprocessTerminator._logDebug(`tracking #${pid}`);\r\n  }\r\n\r\n  public static killProcessTree(\r\n    subprocess: child_process.ChildProcess,\r\n    subprocessOptions: ISubprocessOptions\r\n  ): void {\r\n    const pid: number = subprocess.pid;\r\n\r\n    // Don't attempt to kill the same process twice\r\n    if (SubprocessTerminator._subprocessesByPid.has(pid)) {\r\n      SubprocessTerminator._logDebug(`untracking #${pid} via killProcessTree()`);\r\n      this._subprocessesByPid.delete(subprocess.pid);\r\n    }\r\n\r\n    SubprocessTerminator._validateSubprocessOptions(subprocessOptions);\r\n\r\n    if (typeof subprocess.exitCode === 'number') {\r\n      // Process has already been killed\r\n      return;\r\n    }\r\n\r\n    SubprocessTerminator._logDebug(`terminating #${subprocess.pid}`);\r\n\r\n    if (SubprocessTerminator._isWindows) {\r\n      // On Windows we have a problem that CMD.exe launches child processes, but when CMD.exe is killed\r\n      // the child processes may continue running.  Also if we send signals to CMD.exe the child processes\r\n      // will not receive them.  The safest solution is not to attempt a graceful shutdown, but simply\r\n      // kill the entire process tree.\r\n      const result: child_process.SpawnSyncReturns<string> = Executable.spawnSync('TaskKill.exe', [\r\n        '/T', // \"Terminates the specified process and any child processes which were started by it.\"\r\n        '/F', // Without this, TaskKill will try to use WM_CLOSE which doesn't work with CLI tools\r\n        '/PID',\r\n        subprocess.pid.toString()\r\n      ]);\r\n\r\n      if (result.status) {\r\n        const output: string = result.output.join('\\n');\r\n        // Nonzero exit code\r\n        if (output.indexOf('not found') >= 0) {\r\n          // The PID does not exist\r\n        } else {\r\n          // Another error occurred, for example TaskKill.exe does not support\r\n          // the expected CLI syntax\r\n          throw new Error(`TaskKill.exe returned exit code ${result.status}:\\n` + output + '\\n');\r\n        }\r\n      }\r\n    } else {\r\n      // Passing a negative PID terminates the entire group instead of just the one process\r\n      process.kill(-subprocess.pid, 'SIGKILL');\r\n    }\r\n  }\r\n\r\n  // Install the hooks\r\n  private static _ensureInitialized(): void {\r\n    if (!SubprocessTerminator._initialized) {\r\n      SubprocessTerminator._initialized = true;\r\n\r\n      SubprocessTerminator._logDebug('initialize');\r\n\r\n      process.prependListener('SIGTERM', SubprocessTerminator._onTerminateSignal);\r\n      process.prependListener('SIGINT', SubprocessTerminator._onTerminateSignal);\r\n\r\n      process.prependListener('exit', SubprocessTerminator._onExit);\r\n    }\r\n  }\r\n\r\n  // Uninstall the hooks and perform cleanup\r\n  private static _cleanupChildProcesses(): void {\r\n    if (SubprocessTerminator._initialized) {\r\n      SubprocessTerminator._initialized = false;\r\n\r\n      process.removeListener('SIGTERM', SubprocessTerminator._onTerminateSignal);\r\n      process.removeListener('SIGINT', SubprocessTerminator._onTerminateSignal);\r\n\r\n      const trackedSubprocesses: ITrackedSubprocess[] = Array.from(\r\n        SubprocessTerminator._subprocessesByPid.values()\r\n      );\r\n\r\n      let firstError: Error | undefined = undefined;\r\n\r\n      for (const trackedSubprocess of trackedSubprocesses) {\r\n        try {\r\n          SubprocessTerminator.killProcessTree(trackedSubprocess.subprocess, { detached: true });\r\n        } catch (error) {\r\n          if (firstError === undefined) {\r\n            firstError = error;\r\n          }\r\n        }\r\n      }\r\n\r\n      if (firstError !== undefined) {\r\n        // This is generally an unexpected error such as the TaskKill.exe command not being found,\r\n        // not a trivial issue such as a nonexistent PID.   Since this occurs during process shutdown,\r\n        // we should not interfere with control flow by throwing an exception  or calling process.exit().\r\n        // So simply write to STDERR and ensure our exit code indicates the problem.\r\n        console.error('\\nAn unexpected error was encountered while attempting to clean up child processes:');\r\n        console.error(firstError.toString());\r\n        if (!process.exitCode) {\r\n          process.exitCode = 1;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  private static _validateSubprocessOptions(subprocessOptions: ISubprocessOptions): void {\r\n    if (!SubprocessTerminator._isWindows) {\r\n      if (!subprocessOptions.detached) {\r\n        // Setting detached=true is what creates the process group that we use to kill the children\r\n        throw new Error('killProcessTree() requires detached=true on this operating system');\r\n      }\r\n    }\r\n  }\r\n\r\n  private static _onExit(exitCode: number): void {\r\n    SubprocessTerminator._logDebug(`received exit(${exitCode})`);\r\n\r\n    SubprocessTerminator._cleanupChildProcesses();\r\n\r\n    SubprocessTerminator._logDebug(`finished exit()`);\r\n  }\r\n\r\n  private static _onTerminateSignal(signal: string): void {\r\n    SubprocessTerminator._logDebug(`received signal ${signal}`);\r\n\r\n    SubprocessTerminator._cleanupChildProcesses();\r\n\r\n    // When a listener is added to SIGTERM, Node.js strangely provides no way to reference\r\n    // the original handler.  But we can invoke it by removing our listener and then resending\r\n    // the signal to our own process.\r\n    SubprocessTerminator._logDebug(`relaying ${signal}`);\r\n    process.kill(process.pid, signal);\r\n  }\r\n\r\n  // For debugging\r\n  private static _logDebug(message: string): void {\r\n    //const logLine: string = `SubprocessTerminator: [${process.pid}] ${message}`;\r\n    // fs.writeFileSync('trace.log', logLine + '\\n', { flag: 'a' });\r\n    //console.log(logLine);\r\n  }\r\n}\r\n"]}