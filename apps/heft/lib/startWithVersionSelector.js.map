{"version":3,"file":"startWithVersionSelector.js","sourceRoot":"","sources":["../src/startWithVersionSelector.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\n// NOTE: Since startWithVersionSelector.ts is loaded in the same process as start.ts, any dependencies that\r\n// we import here may become side-by-side versions.  We want to minimize any dependencies.\r\nimport * as path from 'path';\r\nimport * as fs from 'fs';\r\nimport type { IPackageJson } from '@rushstack/node-core-library';\r\n\r\nconst HEFT_PACKAGE_NAME: string = '@rushstack/heft';\r\n\r\n// Excerpted from PackageJsonLookup.tryGetPackageFolderFor()\r\nfunction tryGetPackageFolderFor(resolvedFileOrFolderPath: string): string | undefined {\r\n  // Two lookups are required, because get() cannot distinguish the undefined value\r\n  // versus a missing key.\r\n  // if (this._packageFolderCache.has(resolvedFileOrFolderPath)) {\r\n  //   return this._packageFolderCache.get(resolvedFileOrFolderPath);\r\n  // }\r\n\r\n  // Is resolvedFileOrFolderPath itself a folder with a package.json file?  If so, return it.\r\n  if (fs.existsSync(path.join(resolvedFileOrFolderPath, 'package.json'))) {\r\n    // this._packageFolderCache.set(resolvedFileOrFolderPath, resolvedFileOrFolderPath);\r\n    return resolvedFileOrFolderPath;\r\n  }\r\n\r\n  // Otherwise go up one level\r\n  const parentFolder: string | undefined = path.dirname(resolvedFileOrFolderPath);\r\n  if (!parentFolder || parentFolder === resolvedFileOrFolderPath) {\r\n    // We reached the root directory without finding a package.json file,\r\n    // so cache the negative result\r\n    // this._packageFolderCache.set(resolvedFileOrFolderPath, undefined);\r\n    return undefined; // no match\r\n  }\r\n\r\n  // Recurse upwards, caching every step along the way\r\n  const parentResult: string | undefined = tryGetPackageFolderFor(parentFolder);\r\n  // Cache the parent's answer as well\r\n  // this._packageFolderCache.set(resolvedFileOrFolderPath, parentResult);\r\n\r\n  return parentResult;\r\n}\r\n\r\n/**\r\n * When Heft is invoked via the shell path, we examine the project's package.json dependencies and try to load\r\n * the locally installed version of Heft. This avoids accidentally building using the wrong version of Heft.\r\n * Use \"heft --unmanaged\" to bypass this feature.\r\n */\r\nfunction tryStartLocalHeft(): boolean {\r\n  if (process.argv.indexOf('--unmanaged') >= 0) {\r\n    console.log('(Bypassing the Heft version selector because \"--unmanaged\" was specified.)');\r\n    console.log();\r\n    return false;\r\n  } else if (process.argv.indexOf('--debug') >= 0) {\r\n    // The unmanaged flag could be undiscoverable if it's not in their locally installed version\r\n    console.log(\r\n      'Searching for a locally installed version of Heft. Use the --unmanaged flag if you want to avoid this'\r\n    );\r\n  }\r\n\r\n  // Find the package.json file that governs the current folder location\r\n  const projectFolder: string | undefined = tryGetPackageFolderFor(process.cwd());\r\n  if (projectFolder) {\r\n    let heftEntryPoint: string;\r\n    try {\r\n      const packageJsonPath: string = path.join(projectFolder, 'package.json');\r\n      const packageJsonContent: string = fs.readFileSync(packageJsonPath).toString();\r\n      let packageJson: IPackageJson;\r\n      try {\r\n        packageJson = JSON.parse(packageJsonContent);\r\n      } catch (error) {\r\n        throw new Error(`Error parsing ${packageJsonPath}:` + error.message);\r\n      }\r\n\r\n      // Does package.json have a dependency on Heft?\r\n      if (\r\n        !(packageJson.dependencies && packageJson.dependencies[HEFT_PACKAGE_NAME]) &&\r\n        !(packageJson.devDependencies && packageJson.devDependencies[HEFT_PACKAGE_NAME])\r\n      ) {\r\n        // No explicit dependency on Heft\r\n        return false;\r\n      }\r\n\r\n      // To avoid a loading the \"resolve\" NPM package, let's assume that the Heft dependency must be\r\n      // installed as \"<projectFolder>/node_modules/@rushstack/heft\".\r\n      const heftFolder: string = path.join(projectFolder, 'node_modules', HEFT_PACKAGE_NAME);\r\n\r\n      heftEntryPoint = path.join(heftFolder, 'lib', 'start.js');\r\n      if (!fs.existsSync(heftEntryPoint)) {\r\n        throw new Error('Unable to find Heft entry point: ' + heftEntryPoint);\r\n      }\r\n      console.log(`Using local Heft from ${heftFolder}`);\r\n      console.log();\r\n    } catch (error) {\r\n      throw new Error('Error probing for local Heft version: ' + error.message);\r\n    }\r\n\r\n    require(heftEntryPoint);\r\n\r\n    // We found and successfully invoked the local Heft\r\n    return true;\r\n  }\r\n\r\n  // We couldn't find the package folder\r\n  return false;\r\n}\r\n\r\nif (!tryStartLocalHeft()) {\r\n  // A project Heft dependency was not found, so launch the unmanaged version.\r\n  require('./start.js');\r\n}\r\n"]}