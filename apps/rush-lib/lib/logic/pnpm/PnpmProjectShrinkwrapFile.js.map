{"version":3,"file":"PnpmProjectShrinkwrapFile.js","sourceRoot":"","sources":["../../../src/logic/pnpm/PnpmProjectShrinkwrapFile.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport * as crypto from 'crypto';\r\nimport { InternalError, JsonFile } from '@rushstack/node-core-library';\r\n\r\nimport { BaseProjectShrinkwrapFile } from '../base/BaseProjectShrinkwrapFile';\r\nimport {\r\n  PnpmShrinkwrapFile,\r\n  IPnpmShrinkwrapDependencyYaml,\r\n  IPnpmShrinkwrapImporterYaml\r\n} from './PnpmShrinkwrapFile';\r\nimport { DependencySpecifier } from '../DependencySpecifier';\r\nimport { RushConstants } from '../RushConstants';\r\n\r\n/**\r\n *\r\n */\r\nexport class PnpmProjectShrinkwrapFile extends BaseProjectShrinkwrapFile {\r\n  /**\r\n   * Generate and write the project shrinkwrap file to <project>/.rush/temp/shrinkwrap-deps.json.\r\n   * @returns True if the project shrinkwrap was created or updated, false otherwise.\r\n   */\r\n  public async updateProjectShrinkwrapAsync(): Promise<void> {\r\n    const projectShrinkwrapMap: Map<string, string> | undefined = this.shrinkwrapFile.isWorkspaceCompatible\r\n      ? this.generateWorkspaceProjectShrinkwrapMap()\r\n      : this.generateLegacyProjectShrinkwrapMap();\r\n\r\n    return projectShrinkwrapMap ? this.saveAsync(projectShrinkwrapMap) : this.deleteIfExistsAsync();\r\n  }\r\n\r\n  protected generateWorkspaceProjectShrinkwrapMap(): Map<string, string> | undefined {\r\n    // Obtain the workspace importer from the shrinkwrap, which lists resolved dependencies\r\n    const importerKey: string = this.shrinkwrapFile.getImporterKeyByPath(\r\n      this.project.rushConfiguration.commonTempFolder,\r\n      this.project.projectFolder\r\n    );\r\n    const importer: IPnpmShrinkwrapImporterYaml | undefined = this.shrinkwrapFile.getImporter(importerKey);\r\n    if (!importer) {\r\n      // It's not in here. This is possible when perfoming filtered installs\r\n      return undefined;\r\n    }\r\n\r\n    // Only select the importer dependencies that are non-local since we already handle local\r\n    // project changes\r\n    const externalDependencies: [string, string][] = [\r\n      ...Object.entries(importer.dependencies || {}),\r\n      ...Object.entries(importer.devDependencies || {}),\r\n      ...Object.entries(importer.optionalDependencies || {})\r\n    ].filter((d) => d[1].indexOf('link:') === -1);\r\n\r\n    const projectShrinkwrapMap: Map<string, string> = new Map();\r\n    for (const [name, version] of externalDependencies) {\r\n      // Add to the manifest and provide all the parent dependencies\r\n      this._addDependencyRecursive(projectShrinkwrapMap, name, version, {\r\n        dependencies: { ...importer.dependencies, ...importer.devDependencies },\r\n        optionalDependencies: { ...importer.optionalDependencies }\r\n      });\r\n    }\r\n\r\n    return projectShrinkwrapMap;\r\n  }\r\n\r\n  protected generateLegacyProjectShrinkwrapMap(): Map<string, string> {\r\n    const tempProjectDependencyKey: string | undefined = this.shrinkwrapFile.getTempProjectDependencyKey(\r\n      this.project.tempProjectName\r\n    );\r\n    if (!tempProjectDependencyKey) {\r\n      throw new Error(`Cannot get dependency key for temp project: ${this.project.tempProjectName}`);\r\n    }\r\n    const parentShrinkwrapEntry: IPnpmShrinkwrapDependencyYaml =\r\n      this.shrinkwrapFile.getShrinkwrapEntryFromTempProjectDependencyKey(tempProjectDependencyKey)!;\r\n\r\n    // Only select the shrinkwrap dependencies that are non-local since we already handle local\r\n    // project changes\r\n    const externalDependencies: [string, string][] = [\r\n      ...Object.entries(parentShrinkwrapEntry.dependencies || {}),\r\n      ...Object.entries(parentShrinkwrapEntry.optionalDependencies || {})\r\n    ].filter((d) => d[0].indexOf('@rush-temp/') === -1);\r\n\r\n    const projectShrinkwrapMap: Map<string, string> = new Map();\r\n    for (const [name, version] of externalDependencies) {\r\n      this._addDependencyRecursive(projectShrinkwrapMap, name, version, parentShrinkwrapEntry);\r\n    }\r\n\r\n    // Since peer dependencies within on external packages may be hoisted up to the top-level package,\r\n    // we need to resolve and add these dependencies directly\r\n    this._resolveAndAddPeerDependencies(projectShrinkwrapMap, parentShrinkwrapEntry);\r\n\r\n    return projectShrinkwrapMap;\r\n  }\r\n\r\n  private _addDependencyRecursive(\r\n    projectShrinkwrapMap: Map<string, string>,\r\n    name: string,\r\n    version: string,\r\n    parentShrinkwrapEntry: IPnpmShrinkwrapDependencyYaml,\r\n    throwIfShrinkwrapEntryMissing: boolean = true\r\n  ): void {\r\n    const shrinkwrapEntry: IPnpmShrinkwrapDependencyYaml | undefined = this.shrinkwrapFile.getShrinkwrapEntry(\r\n      name,\r\n      version\r\n    );\r\n\r\n    if (!shrinkwrapEntry) {\r\n      if (throwIfShrinkwrapEntryMissing) {\r\n        throw new InternalError(`Unable to find dependency ${name} with version ${version} in shrinkwrap.`);\r\n      }\r\n      return;\r\n    }\r\n\r\n    const specifier: string = `${name}@${version}`;\r\n    let integrity: string | undefined = shrinkwrapEntry?.resolution?.integrity;\r\n    if (!integrity) {\r\n      // git dependency specifiers do not have an integrity entry. Instead, they specify the tarball field.\r\n      // So instead, we will hash the contents of the dependency entry and use that as the integrity hash.\r\n      // Ex:\r\n      // github.com/chfritz/node-xmlrpc/948db2fbd0260e5d56ed5ba58df0f5b6599bbe38:\r\n      //   ...\r\n      //   resolution:\r\n      //     tarball: 'https://codeload.github.com/chfritz/node-xmlrpc/tar.gz/948db2fbd0260e5d56ed5ba58df0f5b6599bbe38'\r\n      const sha256Digest: string = crypto\r\n        .createHash('sha256')\r\n        .update(JSON.stringify(shrinkwrapEntry))\r\n        .digest('hex');\r\n      integrity = `${name}@${version}:${sha256Digest}:`;\r\n    }\r\n\r\n    const existingSpecifier: string | undefined = projectShrinkwrapMap.get(specifier);\r\n    if (existingSpecifier) {\r\n      if (existingSpecifier !== integrity) {\r\n        throw new Error(`Collision: ${specifier} already exists in with a different integrity`);\r\n      }\r\n      return;\r\n    }\r\n\r\n    // Add the current dependency\r\n    projectShrinkwrapMap.set(specifier, integrity);\r\n\r\n    // Add the dependencies of the dependency\r\n    for (const [name, version] of Object.entries(shrinkwrapEntry.dependencies || {})) {\r\n      this._addDependencyRecursive(projectShrinkwrapMap, name, version, shrinkwrapEntry);\r\n    }\r\n\r\n    // Add the optional dependencies of the dependency, and don't blow up if they don't exist\r\n    for (const [name, version] of Object.entries(shrinkwrapEntry.optionalDependencies || {})) {\r\n      this._addDependencyRecursive(\r\n        projectShrinkwrapMap,\r\n        name,\r\n        version,\r\n        shrinkwrapEntry,\r\n        /* throwIfShrinkwrapEntryMissing */ false\r\n      );\r\n    }\r\n\r\n    // When using workspaces, hoisting of peer dependencies to a singular top-level project is not possible.\r\n    // Therefore, all packages that are consumed should be specified in the dependency tree. Given this, there\r\n    // is no need to look for peer dependencies, since it is simply a constraint to be validated by the\r\n    // package manager.\r\n    if (!this.shrinkwrapFile.isWorkspaceCompatible) {\r\n      this._resolveAndAddPeerDependencies(projectShrinkwrapMap, shrinkwrapEntry, parentShrinkwrapEntry);\r\n    }\r\n  }\r\n\r\n  private _resolveAndAddPeerDependencies(\r\n    projectShrinkwrapMap: Map<string, string>,\r\n    shrinkwrapEntry: IPnpmShrinkwrapDependencyYaml,\r\n    parentShrinkwrapEntry?: IPnpmShrinkwrapDependencyYaml\r\n  ): void {\r\n    for (const peerDependencyName of Object.keys(shrinkwrapEntry.peerDependencies || {})) {\r\n      // Skip peer dependency resolution of local package peer dependencies\r\n      if (peerDependencyName.indexOf(RushConstants.rushTempNpmScope) !== -1) {\r\n        continue;\r\n      }\r\n\r\n      // Check to see if the peer dependency is satisfied with the current shrinkwrap\r\n      // entry. If not, check the parent shrinkwrap entry. Finally, if neither have\r\n      // the specified dependency, check that the parent mentions the dependency in\r\n      // it's own peer dependencies. If it is, we can rely on the package manager and\r\n      // make the assumption that we've already found it further up the stack.\r\n      if (\r\n        shrinkwrapEntry.dependencies?.hasOwnProperty(peerDependencyName) ||\r\n        parentShrinkwrapEntry?.dependencies?.hasOwnProperty(peerDependencyName) ||\r\n        parentShrinkwrapEntry?.peerDependencies?.hasOwnProperty(peerDependencyName)\r\n      ) {\r\n        continue;\r\n      }\r\n\r\n      // As a last attempt, check if it's been hoisted up as a top-level dependency. If\r\n      // we can't find it, we can assume that it's already been provided somewhere up the\r\n      // dependency tree.\r\n      const topLevelDependencySpecifier: DependencySpecifier | undefined =\r\n        this.shrinkwrapFile.getTopLevelDependencyVersion(peerDependencyName);\r\n\r\n      if (topLevelDependencySpecifier) {\r\n        this._addDependencyRecursive(\r\n          projectShrinkwrapMap,\r\n          peerDependencyName,\r\n          this.shrinkwrapFile.getTopLevelDependencyKey(peerDependencyName)!,\r\n          shrinkwrapEntry\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Save the current state of the object to project/.rush/temp/shrinkwrap-deps.json\r\n   */\r\n  protected async saveAsync(projectShrinkwrapMap: Map<string, string>): Promise<void> {\r\n    const file: { [specifier: string]: string } = {};\r\n    const keys: string[] = Array.from(projectShrinkwrapMap.keys()).sort();\r\n    for (const key of keys) {\r\n      file[key] = projectShrinkwrapMap.get(key)!;\r\n    }\r\n    await JsonFile.saveAsync(file, this.projectShrinkwrapFilePath, { ensureFolderExists: true });\r\n  }\r\n\r\n  /**\r\n   * @override\r\n   */\r\n  protected get shrinkwrapFile(): PnpmShrinkwrapFile {\r\n    return super.shrinkwrapFile as PnpmShrinkwrapFile;\r\n  }\r\n}\r\n"]}