{"version":3,"file":"PackageChangeAnalyzer.js","sourceRoot":"","sources":["../../src/logic/PackageChangeAnalyzer.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport * as path from 'path';\r\nimport colors from 'colors/safe';\r\nimport * as crypto from 'crypto';\r\nimport ignore, { Ignore } from 'ignore';\r\n\r\nimport { getPackageDeps, getGitHashForFiles } from '@rushstack/package-deps-hash';\r\nimport { Path, InternalError, FileSystem, Terminal, Async } from '@rushstack/node-core-library';\r\n\r\nimport { RushConfiguration } from '../api/RushConfiguration';\r\nimport { RushProjectConfiguration } from '../api/RushProjectConfiguration';\r\nimport { Git } from './Git';\r\nimport { BaseProjectShrinkwrapFile } from './base/BaseProjectShrinkwrapFile';\r\nimport { RushConfigurationProject } from '../api/RushConfigurationProject';\r\nimport { RushConstants } from './RushConstants';\r\n\r\nexport class PackageChangeAnalyzer {\r\n  /**\r\n   * null === we haven't looked\r\n   * undefined === data isn't available (i.e. - git isn't present)\r\n   */\r\n  private _data: Map<string, Map<string, string>> | undefined | null = null;\r\n  private _projectStateCache: Map<string, string> = new Map<string, string>();\r\n  private _rushConfiguration: RushConfiguration;\r\n  private readonly _git: Git;\r\n\r\n  public constructor(rushConfiguration: RushConfiguration) {\r\n    this._rushConfiguration = rushConfiguration;\r\n    this._git = new Git(this._rushConfiguration);\r\n  }\r\n\r\n  public async getPackageDeps(\r\n    projectName: string,\r\n    terminal: Terminal\r\n  ): Promise<Map<string, string> | undefined> {\r\n    if (this._data === null) {\r\n      this._data = await this._getData(terminal);\r\n    }\r\n\r\n    return this._data?.get(projectName);\r\n  }\r\n\r\n  /**\r\n   * The project state hash is calculated in the following way:\r\n   * - Project dependencies are collected (see PackageChangeAnalyzer.getPackageDeps)\r\n   *   - If project dependencies cannot be collected (i.e. - if Git isn't available),\r\n   *     this function returns `undefined`\r\n   * - The (path separator normalized) repo-root-relative dependencies' file paths are sorted\r\n   * - A SHA1 hash is created and each (sorted) file path is fed into the hash and then its\r\n   *   Git SHA is fed into the hash\r\n   * - A hex digest of the hash is returned\r\n   */\r\n  public async getProjectStateHash(projectName: string, terminal: Terminal): Promise<string | undefined> {\r\n    let projectState: string | undefined = this._projectStateCache.get(projectName);\r\n    if (!projectState) {\r\n      const packageDeps: Map<string, string> | undefined = await this.getPackageDeps(projectName, terminal);\r\n      if (!packageDeps) {\r\n        return undefined;\r\n      } else {\r\n        const sortedPackageDepsFiles: string[] = Array.from(packageDeps.keys()).sort();\r\n        const hash: crypto.Hash = crypto.createHash('sha1');\r\n        for (const packageDepsFile of sortedPackageDepsFiles) {\r\n          hash.update(packageDepsFile);\r\n          hash.update(RushConstants.hashDelimiter);\r\n          hash.update(packageDeps.get(packageDepsFile)!);\r\n          hash.update(RushConstants.hashDelimiter);\r\n        }\r\n\r\n        projectState = hash.digest('hex');\r\n        this._projectStateCache.set(projectName, projectState);\r\n      }\r\n    }\r\n\r\n    return projectState;\r\n  }\r\n\r\n  private async _getData(terminal: Terminal): Promise<Map<string, Map<string, string>> | undefined> {\r\n    const repoDeps: Map<string, string> | undefined = this._getRepoDeps();\r\n    if (!repoDeps) {\r\n      return undefined;\r\n    }\r\n\r\n    const projectHashDeps: Map<string, Map<string, string>> = new Map<string, Map<string, string>>();\r\n    const ignoreMatcherForProject: Map<string, Ignore> = new Map<string, Ignore>();\r\n\r\n    // Initialize maps for each project asynchronously, up to 10 projects concurrently.\r\n    await Async.forEachAsync(\r\n      this._rushConfiguration.projects,\r\n      async (project: RushConfigurationProject): Promise<void> => {\r\n        projectHashDeps.set(project.packageName, new Map<string, string>());\r\n        ignoreMatcherForProject.set(\r\n          project.packageName,\r\n          await this._getIgnoreMatcherForProject(project, terminal)\r\n        );\r\n      },\r\n      { concurrency: 10 }\r\n    );\r\n\r\n    // Sort each project folder into its own package deps hash\r\n    for (const [filePath, fileHash] of repoDeps) {\r\n      // findProjectForPosixRelativePath uses LookupByPath, for which lookups are O(K)\r\n      // K being the maximum folder depth of any project in rush.json (usually on the order of 3)\r\n      const owningProject: RushConfigurationProject | undefined =\r\n        this._rushConfiguration.findProjectForPosixRelativePath(filePath);\r\n      if (owningProject) {\r\n        // At this point, `filePath` is guaranteed to start with `projectRelativeFolder`, so\r\n        // we can safely slice off the first N characters to get the file path relative to the\r\n        // root of the `owningProject`.\r\n        const relativePath: string = filePath.slice(owningProject.projectRelativeFolder.length + 1);\r\n        const ignoreMatcher: Ignore | undefined = ignoreMatcherForProject.get(owningProject.packageName);\r\n        if (!ignoreMatcher || !ignoreMatcher.ignores(relativePath)) {\r\n          projectHashDeps.get(owningProject.packageName)!.set(filePath, fileHash);\r\n        }\r\n      }\r\n    }\r\n\r\n    // Currently, only pnpm handles project shrinkwraps\r\n    if (this._rushConfiguration.packageManager === 'pnpm') {\r\n      const projects: RushConfigurationProject[] = [];\r\n      const projectDependencyManifestPaths: string[] = [];\r\n\r\n      for (const project of this._rushConfiguration.projects) {\r\n        const projectShrinkwrapFilePath: string = BaseProjectShrinkwrapFile.getFilePathForProject(project);\r\n        const relativeProjectShrinkwrapFilePath: string = Path.convertToSlashes(\r\n          path.relative(this._rushConfiguration.rushJsonFolder, projectShrinkwrapFilePath)\r\n        );\r\n\r\n        if (!FileSystem.exists(projectShrinkwrapFilePath)) {\r\n          throw new Error(\r\n            `A project dependency file (${relativeProjectShrinkwrapFilePath}) is missing. You may need to run ` +\r\n              '\"rush install\" or \"rush update\".'\r\n          );\r\n        }\r\n\r\n        projects.push(project);\r\n        projectDependencyManifestPaths.push(relativeProjectShrinkwrapFilePath);\r\n      }\r\n\r\n      const gitPath: string = this._git.getGitPathOrThrow();\r\n      const hashes: Map<string, string> = getGitHashForFiles(\r\n        projectDependencyManifestPaths,\r\n        this._rushConfiguration.rushJsonFolder,\r\n        gitPath\r\n      );\r\n      for (let i: number = 0; i < projects.length; i++) {\r\n        const project: RushConfigurationProject = projects[i];\r\n        const projectDependencyManifestPath: string = projectDependencyManifestPaths[i];\r\n        if (!hashes.has(projectDependencyManifestPath)) {\r\n          throw new InternalError(`Expected to get a hash for ${projectDependencyManifestPath}`);\r\n        }\r\n\r\n        const hash: string = hashes.get(projectDependencyManifestPath)!;\r\n        projectHashDeps.get(project.packageName)!.set(projectDependencyManifestPath, hash);\r\n      }\r\n    } else {\r\n      // Determine the current variant from the link JSON.\r\n      const variant: string | undefined = this._rushConfiguration.currentInstalledVariant;\r\n\r\n      // Add the shrinkwrap file to every project's dependencies\r\n      const shrinkwrapFile: string = Path.convertToSlashes(\r\n        path.relative(\r\n          this._rushConfiguration.rushJsonFolder,\r\n          this._rushConfiguration.getCommittedShrinkwrapFilename(variant)\r\n        )\r\n      );\r\n\r\n      for (const project of this._rushConfiguration.projects) {\r\n        const shrinkwrapHash: string | undefined = repoDeps!.get(shrinkwrapFile);\r\n        if (shrinkwrapHash) {\r\n          projectHashDeps.get(project.packageName)!.set(shrinkwrapFile, shrinkwrapHash);\r\n        }\r\n      }\r\n    }\r\n\r\n    return projectHashDeps;\r\n  }\r\n\r\n  private async _getIgnoreMatcherForProject(\r\n    project: RushConfigurationProject,\r\n    terminal: Terminal\r\n  ): Promise<Ignore> {\r\n    const projectConfiguration: RushProjectConfiguration | undefined =\r\n      await RushProjectConfiguration.tryLoadForProjectAsync(project, undefined, terminal);\r\n    const ignoreMatcher: Ignore = ignore();\r\n\r\n    if (projectConfiguration && projectConfiguration.incrementalBuildIgnoredGlobs) {\r\n      ignoreMatcher.add(projectConfiguration.incrementalBuildIgnoredGlobs);\r\n    }\r\n\r\n    return ignoreMatcher;\r\n  }\r\n\r\n  private _getRepoDeps(): Map<string, string> | undefined {\r\n    try {\r\n      if (this._git.isPathUnderGitWorkingTree()) {\r\n        // Load the package deps hash for the whole repository\r\n        const gitPath: string = this._git.getGitPathOrThrow();\r\n        return getPackageDeps(this._rushConfiguration.rushJsonFolder, [], gitPath);\r\n      } else {\r\n        return undefined;\r\n      }\r\n    } catch (e) {\r\n      // If getPackageDeps fails, don't fail the whole build. Treat this case as if we don't know anything about\r\n      // the state of the files in the repo. This can happen if the environment doesn't have Git.\r\n      console.log(\r\n        colors.yellow(\r\n          `Error calculating the state of the repo. (inner error: ${e}). Continuing without diffing files.`\r\n        )\r\n      );\r\n\r\n      return undefined;\r\n    }\r\n  }\r\n}\r\n"]}