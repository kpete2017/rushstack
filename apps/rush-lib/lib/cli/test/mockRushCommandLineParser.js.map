{"version":3,"file":"mockRushCommandLineParser.js","sourceRoot":"","sources":["../../../src/cli/test/mockRushCommandLineParser.ts"],"names":[],"mappings":";AAAA,4FAA4F;AAC5F,2DAA2D;AAE3D,kFAAkF;AAClF,IAAI,CAAC,IAAI,CAAC,eAAe,CAAC,CAAC;AAE3B,SAAS,6BAA6B,CAAC,KAAY;IACjD,wDAAwD;IACxD,MAAM,KAAK,CAAC;AACd,CAAC;AAED;;GAEG;AACH,IAAI,CAAC,IAAI,CAAC,0BAA0B,EAAE,GAAG,EAAE;IACzC,8DAA8D;IAC9D,MAAM,YAAY,GAAQ,IAAI,CAAC,aAAa,CAAC,0BAA0B,CAAC,CAAC;IACzE,IAAI,YAAY,CAAC,qBAAqB,EAAE;QACtC,4DAA4D;QAC5D,YAAY,CAAC,qBAAqB,CAAC,SAAS,CAAC,0BAA0B,GAAG,6BAA6B,CAAC;KACzG;IACD,OAAO,YAAY,CAAC;AACtB,CAAC,CAAC,CAAC","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\n// Mock child_process so we can verify tasks are (or are not) invoked as we expect\r\njest.mock('child_process');\r\n\r\nfunction mockReportErrorAndSetExitCode(error: Error): void {\r\n  // Just rethrow the error so the unit tests can catch it\r\n  throw error;\r\n}\r\n\r\n/**\r\n * Mock RushCommandLineParser itself to prevent `process.exit` to be called on failure\r\n */\r\njest.mock('../RushCommandLineParser', () => {\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  const actualModule: any = jest.requireActual('../RushCommandLineParser');\r\n  if (actualModule.RushCommandLineParser) {\r\n    // Stub out the troublesome method that calls `process.exit`\r\n    actualModule.RushCommandLineParser.prototype._reportErrorAndSetExitCode = mockReportErrorAndSetExitCode;\r\n  }\r\n  return actualModule;\r\n});\r\n"]}